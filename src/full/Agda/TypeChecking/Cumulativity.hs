module Agda.TypeChecking.Cumulativity where

import Data.Maybe
import Data.List ((\\), delete, intersect, group, sort, concat)
import Data.Traversable (Traversable)
import Data.Map (Map, (!), keys, unionWith, foldrWithKey, insert, empty)
import qualified Data.Map as Map (map,fold)
import Data.Set (Set)
import qualified Data.Set as Set (union, fromList, insert, null, intersection, unions, empty)
import Control.Monad

import Agda.Interaction.Options

import Agda.Syntax.Common
import Agda.Syntax.Internal

import Agda.TypeChecking.Monad

import Agda.Utils.Impossible
import Control.Exception (assert)
import Agda.TypeChecking.Primitive (Lvl)
import Debug.Trace (trace)

{-# OPTIONS_GHC -ddump-simpl-stats #-}

--remove duplicates from a given list, and reorders it
remove_dups :: (Ord a) => [a] -> [a]
remove_dups = map head . group . sort


union :: (Ord k,Ord a) => Map k a -> Map k a -> Map k a
union = unionWith max 

data LvlVariable  =
      VarL {-# UNPACK #-} !Int Elims
    | MetaL {-# UNPACK #-} !MetaId Elims
    deriving (Eq, Ord,Show)

type Presentation = [(LvlVariable,Integer)]

type Horn = (Presentation,(LvlVariable , Integer))

data LevelEq = Eq Presentation Presentation

level_to_presentation :: Level -> Presentation
level_to_presentation (Max i l) =
    map (\(Plus j l) -> (to_var l,i+j)) l
    where
        to_var :: Term -> LvlVariable
        to_var (Var i es) = VarL i es
        to_var (MetaV x es) = MetaL x es
        to_var _ = __IMPOSSIBLE__

cmp_to_eq :: Comparison -> Level -> Level -> LevelEq
cmp_to_eq CmpEq a b = Eq (level_to_presentation a) (level_to_presentation b)
cmp_to_eq CmpLeq a b =
    let a' = level_to_presentation a
        b' = level_to_presentation b
    in Eq a' (a' ++ b')

to_horns :: LevelEq -> [Horn]
to_horns (Eq a b) =
    let a' = map (b,) a
        b' = map (a,) b
    in a' ++ b'

data NInf =
      Nat !Integer
    | NInf
    deriving (Eq, Show)

instance Ord NInf where
    compare (Nat i) (Nat j) = compare i j
    compare (Nat _) NInf = LT
    compare NInf (Nat _) = GT
    compare NInf NInf = EQ

type Model = Map LvlVariable NInf

sorry :: a
sorry = __IMPOSSIBLE__

forward :: [Horn] -> Model -> (Set LvlVariable,Model)
forward h f =
    let forwarded = map forward_one h in
    let !(changed_vars,new_model) = foldl (\(vars,model) maybe  ->
            case maybe of
            Nothing -> (vars,model)
            Just (v,f) -> if f == model ! v then (vars,model) else
                (Set.insert v vars, insert v (max f (model ! v)) model)
            )    
            (Set.empty,f)
            forwarded in
    (changed_vars,new_model)

    where
        -- find the biggest value generated by the clauses in the upwards closure of a single Horn clause
        forward_one :: Horn -> Maybe (LvlVariable,NInf)
        forward_one (x,(v,l)) = do
            -- if the model satisfies the presentation A, return the biggest k such that A + k is also satisfied 
            to_up <- foldM 
                    (\acc (x,k)  -> 
                        let n = f ! x in
                        case f ! x of
                            NInf        -> Just acc
                            Nat n       -> Just $ max 0 $ min acc (n - k)
                    ) 
                    (toInteger (maxBound :: Int)) --TODO convert algorithm to use Int, or find a safe max-bound
                    x  
            case f ! v of
                NInf -> Nothing
                Nat n -> Just (v,Nat $ max n $ to_up + l)
            

simplify_ :: [Horn] -> Model -> Maybe ([Horn],Model)
simplify_ c f =
    let all_finite = foldr (\x b -> b && (x<NInf)) True f in
    if all_finite then Nothing else
    Just $
    foldrWithKey
        (\x k (c,h) -> if k==NInf then (remove x c,h) else (c,insert x k h))
        (c,empty)
        f

    where
        remove x = remove_many [x]

        remove_many [] t = t
        remove_many (x:xs) t =
            let t' = remove_one x t
                l = to_delete xs t in
            remove_many l t'

        remove_one x [] = []
        remove_one x ((_,(y,_)):t) | x==y = remove_one x t
        remove_one x ((l,v):t) = (filter ((==x) . fst) l,v):(remove_one x t)

        to_delete acc [] = acc
        to_delete acc (([],(v,_)):t) = to_delete (v:acc) t
        to_delete acc (_:t) = to_delete acc t

lemma33 :: Set LvlVariable -> Set LvlVariable -> [Horn] -> Model -> Model
lemma33 v w c f =
    let cw = filter (\(x,(y,l)) -> elem y w && all ((flip elem w) . fst) x) c
        g = thm32 w Set.empty cw f
        f_or_g = union f g
        c_down_w = filter (\(x,(y,l)) -> elem y w) c
        (w',g') = forward c_down_w f_or_g in
    if Set.null w' then
        f_or_g
    else
        lemma33 v w c (union f g')

thm32 :: Set LvlVariable -> Set LvlVariable -> [Horn] -> Model -> Model
thm32 v u c f =
    let (w,f') = forward c f in
    if Set.null w then f else
    if Set.union u w == v then Map.map (const NInf) f else
    case simplify_ c f' of
        Just (c',g) ->
            let v' = Set.fromList $ keys g'
                g' = thm32 v' (Set.intersection (Set.union u w) v') c' g in
            union f' g'
        Nothing ->
            let g = lemma33 v (Set.union u w) c f'
                (w',g') = forward c g in
            if Set.null w' then g else
            thm32 v (Set.unions [u,w,w']) c g'


solveCumulativeConstraints :: [Constraint] -> TCM ()
solveCumulativeConstraints l = do
    let toLevelEqConstraints = map (\ (LevelCmp c l1 l2) -> cmp_to_eq c l1 l2) l
    let horns = concat $ map to_horns toLevelEqConstraints
    let vars = Set.fromList $ ((concatMap (map fst) (map (\h -> (snd h):(fst h)) horns)))
    sorry